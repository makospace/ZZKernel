# ZeroOS
搭建一个小型操作系统内核需要一定的编程基础和对计算机系统的理解。以下是一个分步骤的实现方法：

1. 准备工具和环境：
   - 安装一个C编译器，如GCC
   - 安装汇编编译器，如NASM
   - 安装QEMU虚拟机
   - 准备一个文本编辑器，如Visual Studio Code

2. 编写Bootloader：
   - 使用汇编语言编写一个简单的Bootloader，它的主要任务是将操作系统内核从磁盘加载到内存中，并跳转到内核的入口点执行。
   - 编译Bootloader为二进制文件，并使用dd命令将其写入引导扇区。

3. 编写操作系统内核：
   - 使用C语言编写内核的主要部分，包括内核的入口点、初始化硬件、设置中断向量表等。
   - 编写内核的Makefile，用于编译内核并生成内核映像文件。

4. 文件管理：
   - 参考FAT文件系统，实现底层的磁盘读写操作。
   - 实现inode和目录表的数据结构和相关操作。
   - 提供文件操作API，如打开、关闭、读取、写入等。

5. 内存管理：
   - 设计内存分配和回收算法，如buddy system或slab allocator。
   - 实现内存管理的API，如malloc、free等。
   - 实现内存轮调算法，如最近最少使用（LRU）算法。

6. 进程管理：
   - 设计进程控制块（PCB）数据结构，用于存储进程的状态、优先级等信息。
   - 实现进程调度算法，如轮转法（Round Robin）或优先级调度。
   - 实现死锁处理和互斥控制，如银行家算法和信号量。

7. 中断处理：
   - 编写中断服务程序（ISR），用于处理不同类型的中断，如时钟中断、键盘中断等。
   - 在内核初始化时，设置中断向量表，将中断服务程序与相应的中断向量关联。

8. 部署到QEMU虚拟机：
   - 将Bootloader和内核映像文件合并为一个磁盘映像文件。
   - 使用QEMU虚拟机启动磁盘映像文件，观察操作系统内核的运行情况。

这个过程需要不断地调试和优化。在实际操作中，你可能需要参考更多的资料和示例代码。建议你阅读一些操作系统教程和开源项目，如《操作系统真象还原》和Xv6操作系统。

## 具体实现
1. 开始：CS:0xf000, IP:0xfff0，这里存放着BIOS的入口地址，此处只有一条16B的跳转指令，将IP变为0xe05b，进入BIOS基本输入输出系统区，有三个功能（进行硬件自启动检查，进行中断向量表的设置，跳转到MBR（Main Boot Recoder）主引导扇区，IP变为0x7c00，这是历史遗留问题（以前的空间大小的限制），MBR是第0磁道，第0盘，第0扇区的块（512B），最后两个字节是0x55,0xaa,要是不是就继续往后面找，MBR的作用是将操作系统Loader加载进来，然后跳转到对应位置（因为512字节太小，不足以调入操作系统，后面还可以如此进行多次跳转，直到加载完所有操作系统未知，之所以第一次跳不做任务，是因为这是历史遗留问题，默认MRB在0x7c00

2. loader是可以跨越一个扇区的，所以复杂的操作系统就由loader调入，loader里的GDT暂时取代了段表的地位（global description table）

3. 其实这不是完整的自我实现操作系统，否则一开始的编译成二进制或者使用的c代码，都是需要调用底层函数的，但其实这时候操作系统还没有完成，是用宿主机完成的

4. 不断编写elf文件（就是汇编代码，然后编译为elf），然后使用dd存入kernel，再次loader就可以把后面新加的kernel一起加载入内存，比如我编写了print函数（汇编），然后可以使用c语言包含对应头文件，就可以使用自己编写的底层函数了，在自己的虚拟机上是无法使用任何C的函数的，因为其对应的底层汇编函数没有实现，如果实现的非常完备，就像Linux一样，就可以使用其开发新的编程语言，这就是为什么新语言通常要在Linux下开发，可以使用已经有的底层汇编函数，自己新加一些汇编函数也会变得简单
5. 出现中断，到最后找到中断处理程序的入口，这个过程需要硬件配合。当出现中断的时候，硬件会为这个中断分配一个中断号码。然后硬件拿着这个号码，去查找IDT表，找到对应的中断门描述符。从中断门描述符中取出要执行的中断处理程序的cs选择子，与ip偏移。有了cs与ip，硬件自然就能够跳转执行对应的中断处理程序。而我们要做的，就是准备IDT表，准备中断处理程序。然后在IDT表中断对应的中断门描述符中填入中断处理程序的地址。最后将IDT表的地址加载进入IDTR，这样硬件才能找到IDT表，找到中断门描述符，进而找到中断处理程序。kernel.S只是用来存储中断处理程序的文件罢了，中断处理程序的地址已经被填入IDT表对应的中断门描述符中了。
6. 我们不必在kernel.S中直接定义对应的函数比如fork，而是可以给出一个指向，当要执行kernel中的fork时，跳转到对应的代码区（可以使用C来写），就是汇编来调call C，在C中修改的操作，其实就是为了返回或者完善某个数据结构，只要我在汇编里找到这个结构就可以，可以使用extern直接获取call C修改后的数据结构，当然extern是在开始时就执行的，是一个全局结构，汇编call汇编函数，不用push，因为是自带的，但是callC函数，要push pop保护恢复现场，call [id_table + %1 * 4], id_table里存的是一个字符串，是函数名
7. 那为什么可以直接使用汇编呢，其中的寄存器又是怎么和底层对应的呢，这就直接是QEMU的功能了，它是一种免费的开源硬件虚拟化软件，可以模拟多种硬件架构并运行不同操作系统的应用程序。它可以在宿主计算机的不同操作系统上运行，例如Linux、Windows、Mac OS等。QEMU支持许多处理器架构，如x86，ARM，MIPS等。至于可以不可以自己写一个QEMU，这就是硬件工程师的任务了，需要封装底层布线逻辑，给每个寄存器命名和赋予意义，处理时钟频率等
8. 任何文件在本地存储为二进制，分为数据和属性两部分，包括图片